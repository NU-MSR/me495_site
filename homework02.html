<!-- Generated with pandoc -D html
Modified by Matthew Elwin.
-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Matthew Elwin" />
<title>Homework 2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
</style>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
<!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
<![endif]-->
<style type="text/css">
/*
Matthew Elwin
css for the nume template for making websites

Contains code modified from with https://gist.github.com/killercup/5917178
Mostly using the aesthetics from above, but added a table of contents menu to the left.
When printing, the menu will be hidden

*/


nav#TOC{
    width: 20%;
    height: 100%;
    position:fixed!important;
    z-index:1;
    overflow:auto;
    padding-right: 2em;
}

.home_up{
    position: fixed;
    right: 0.25em;
    top: 0.25em;
}
.content{
    margin-left: 21%;
    padding-left: 4em;
}

.inner{
    margin: 0 auto;
    min-width: 30em;
    max-width: 50em;
}

.no-foot{
    min-height: 100vh 
}

.container:after,.container:before{content:"";display:table;clear:both}

.footer {
    font-size: 9pt
}

html {
  font-size: 100%;
  overflow-y: scroll;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
  padding: 0;
}

body {
  font-family: "DejaVu Serif", Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif;
  font-size: 12px;
  line-height: 1.7;
  padding: 1em;
  background: #fefefe;
}

a {
  color: #0645ad;
  text-decoration: none;
}

a:visited {
  color: #0b0080;
}

nav a:visited {
    color: #0645ad;
}

a:hover {
  color: #06e;
}

nav a:hover {
    color: #0645ad;
    background: #C3C3DE
}

a:active {
  color: #faa700;
}

a:focus {
  outline: thin dotted;
}

*::-moz-selection {
  background: rgba(255, 255, 0, 0.3);
  color: #000;
}

*::selection {
  background: rgba(255, 255, 0, 0.3);
  color: #000;
}

a::-moz-selection {
  background: rgba(255, 255, 0, 0.3);
  color: #0645ad;
}

a::selection {
  background: rgba(255, 255, 0, 0.3);
  color: #0645ad;
}

p {
  margin: 1em 0;
}

img {
  max-width: 100%;
}

h1, h2, h3, h4, h5, h6 {
  color: #111;
  line-height: 125%;
  margin-top: 1em;
  font-weight: normal;
}

h4, h5, h6 {
  font-weight: bold;
}

h1 {
  font-size: 2.5em;
}

h1.title {
    margin-top: 0em;
    font-size: 3em;
}

h2 {
  font-size: 2em;
}

h3 {
  font-size: 1.5em;
}

h4 {
  font-size: 1.2em;
}

h5 {
  font-size: 1em;
}

h6 {
  font-size: 0.9em;
}

blockquote {
  color: #666666;
  margin: 0;
  padding-left: 3em;
  border-left: 0.5em #EEE solid;
}

hr {
  display: block;
  height: 2px;
  border: 0;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #eee;
  margin: 1em 0;
  padding: 0;
}

pre, code, kbd, samp {
    color: #000;
    background-color: #f0f0f0;
  border: 1px solid #e1e4e5;
  font-family: monospace, monospace;
  _font-family: 'courier new', monospace;
  font-size: 0.98em;
  line-height: normal;
}

.line-block {
    color: #000;
    background-color: #f0f0f0;
    border: 1px solid #e1e4e5;
}
/* this style is used for inline code blocks 
it is overwridden when inside a pre format block*/
code {
    padding: 0 5px;
    white-space: nowrap;
    font-size: 85%
}

pre {
  white-space: pre;
  white-space: pre-wrap;
  word-wrap: break-word;
}

pre code {
    padding: 0 0;
    white-space: inherit;
    border: 0
}

b, strong {
  font-weight: bold;
}

dfn {
  font-style: italic;
}

ins {
  background: #ff9;
  color: #000;
  text-decoration: none;
}

mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

sub, sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

ul, ol {
  margin: 1em 0;
  padding: 0 0 0 2em;
}

li > ul, li > ol {
    margin: 0 0;
}

nav ul, nav ol {
    list-style: none;
    padding: 0 0 0 0;
}

/* make the top level list item in table of contents not indent*/
nav li > ul, nav li > ol {
    list-style: none;
    padding: 0 0 0 2em;
}

li p:last-child {
  margin-bottom: 0;
}

ul ul, ol ol {
  margin: .3em 0;
}

dl {
  margin-bottom: 1em;
}

dt {
  font-weight: bold;
  margin-bottom: .8em;
}

dd {
  margin: 0 0 .8em 2em;
}

dd:last-child {
  margin-bottom: 0;
}

img {
  border: 0;
  -ms-interpolation-mode: bicubic;
  vertical-align: middle;
}

figure {
  display: block;
  text-align: center;
  margin: 1em 0;
}

figure img {
  border: none;
  margin: 0 auto;
}

figcaption {
  font-size: 0.8em;
  font-style: italic;
  margin: 0 0 .8em;
}

table {
  margin-bottom: 2em;
  border-bottom: 1px solid #ddd;
  border-right: 1px solid #ddd;
  border-spacing: 0;
  border-collapse: collapse;
}

table th {
  padding: .2em 1em;
  background-color: #eee;
  border-top: 1px solid #ddd;
  border-left: 1px solid #ddd;
}

table td {
  padding: .2em 1em;
  border-top: 1px solid #ddd;
  border-left: 1px solid #ddd;
  vertical-align: top;
}

.author {
  font-size: 1.2em;
}

/* When the screen gets too narrow, hide the toc*/
@media only screen and (max-width: 768px) {
    nav {
        visibility: hidden
    }
    .content {
        margin-left: 0;
    }
}

@media only screen and (min-width: 480px) {
  body {
      font-size: 14px;
  }
}
@media only screen and (min-width: 768px) {
  body {
    font-size: 16px;
  }
}
@media print {
  * {
    background: transparent !important;
    color: black !important;
    filter: none !important;
    -ms-filter: none !important;
  }

  nav {
      visibility: hidden;
  }

  .content{
      margin-left: 0%;
      padding-left: 10px;
  }

  body {
    font-size: 10pt;
    max-width: 100%;
  }

  a, a:visited {
    text-decoration: underline;
  }

  hr {
    height: 1px;
    border: 0;
    border-bottom: 1px solid black;
  }

  a[href]:after {
    content: " (" attr(href) ")";
  }

  abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
    content: "";
  }

  pre, blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  tr, img {
    page-break-inside: avoid;
  }

  img {
    max-width: 100% !important;
  }

  @page :left {
    margin: 15mm 20mm 15mm 10mm;
}

  @page :right {
    margin: 15mm 10mm 15mm 20mm;
}

  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }

  h2, h3 {
    page-break-after: avoid;
  }
}


</style> 
</head>
<body>

<!-- Sidebar for table of contents -->
<nav id="TOC" role="doc-toc">
<h3>Table of Contents</h3>
<ul>
<li><a href="#logistics">Logistics</a>
<ul>
<li><a href="#robots">Robots</a></li>
<li><a href="#package-setup">Package Setup</a></li>
</ul></li>
<li><a href="#part-i-turtle-trajectories">Part I: Turtle Trajectories</a>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#the-math">The Math</a></li>
<li><a href="#what-to-implement">What to implement</a></li>
<li><a href="#hints">Hints</a></li>
</ul></li>
<li><a href="#part-ii-xacro-arm">Part II: Xacro ARM</a>
<ul>
<li><a href="#what-to-turn-in">What to turn in</a></li>
</ul></li>
<li><a href="#part-iii-pincherx-100">Part III: PincherX 100</a>
<ul>
<li><a href="#hints-1">Hints</a></li>
</ul></li>
</ul>
</nav>

<nav class="home_up">
  <a href="index.html">Home</a>
</nav>
<div class="content">
  <div class="inner">
    <div class="no-foot">
<!-- Put the header to the right of the table of contents -->
<header id="title-block-header">
<h1 class="title">Homework 2</h1>
</header>

<!-- The main content of the file -->
<h1 id="logistics">Logistics</h1>
<ol>
<li>Create a git repository using the link provided in Canvas.</li>
<li>Your homework will be submitted via this git repository.</li>
<li>I will grade whatever is on the <code>master</code> branch when I clone the repository.</li>
<li>See <a href="./homework/guidelines.html">Guidelines</a> for important information about coding standards</li>
<li>All work on both parts of this problem should be done in a single <code>git</code> repository containing a single ROS package called <code>homework2</code></li>
<li>In general, you should refer to <code>ROS</code> entities using relative names from within your nodes (this advice has been added to the Guidelines).</li>
</ol>
<h2 id="robots">Robots</h2>
<ol>
<li>This assignment will lightly use the <code>turtlebot3</code> robot.
<ul>
<li>Follow my <a href="./turtlebot3.html">setup guide</a></li>
<li>Most of the <a href="https://emanual.robotis.com/docs/en/platform/turtlebot3/overview">official manual</a> applies to our custom setup</li>
</ul></li>
<li>Remote students who do not have access to the robots will complete the project in simulation.</li>
</ol>
<h2 id="package-setup">Package Setup</h2>
<p>The <code>turtlebot3</code> packages have not been released for ROS <code>noetic</code> yet. Therefore, we will compile them and use them from a workspace.</p>
<ol>
<li>Install <code>vcstool</code> (<code>sudo apt install python3-vcstool</code>)</li>
<li>Create a new workspace called <code>basews</code></li>
<li><code>cd basews/src</code></li>
<li><code>vcs import https://nu-msr.github.io/me495_site/turtlebot.repos</code>
<ul>
<li>This command will clone several repositories into your source space</li>
</ul></li>
<li>Install system dependencies with <code>rosdep</code> (install <code>rosdep</code> with <code>sudo apt install python3-rosdep</code>)
<ul>
<li><code>rosdep install --from-paths src/ --ignore-src -y</code></li>
</ul></li>
<li>Build the workspace (<code>cd basews</code> followed by <code>catkin_make</code>)</li>
<li>Source the workspace from your <code>~/.bashrc</code>. This way it will always be active and you can use the packages in every new terminal that you open. Add the line
<ul>
<li><code>source /path/to/basews/devel/setup.bash</code></li>
</ul></li>
<li>Also in your <code>~/.bashrc</code>, <code>export TURTLEBOT3_MODEL=burger</code>. All of the <code>turtlebot3</code> packages use this environment variable to determine which model of turtlebot you are using.</li>
</ol>
<h1 id="part-i-turtle-trajectories">Part I: Turtle Trajectories</h1>
<h2 id="overview">Overview</h2>
<p>The goal of this assignment is to make a turtlebot follow a figure-8 trajectory.</p>
<ol>
<li>The turtlebot will begin in the "paused" state and believe that it's configuration is <span class="math inline">\((x, y, \theta) = (0,0,0)\)</span>.</li>
<li>Upon sending a <code>/reset</code> message, the turtlebot will reset it's configuration to <span class="math inline">\((x, y, \theta) = (0,0,0)\)</span> and enter the "paused" state
<ul>
<li>This will also reset the turtlebot's odometry to be <span class="math inline">\(0, 0, 0\)</span></li>
</ul></li>
<li>Upon calling the <code>/resume</code> service, the turtlebot will enter the "moving" state and begin following the trajectory</li>
<li>Upon calling the <code>/pause</code> service, the turtlebot will pause its motion, without resetting its position</li>
</ol>
<h2 id="the-math">The Math</h2>
<p>The <a href="https://emanual.robotis.com/docs/en/platform/turtlebot3/overview">turtlebot3</a> is a differential-drive robot that can be modeled as kinematic car (also known as a unicycle model). The control inputs for the robot are linear velocity <span class="math inline">\(v\)</span> and the angular velocity <span class="math inline">\(\omega\)</span>, and result in motion according to the kinematic equations</p>
<span class="math display">\[\begin{align}
\dot{x} &amp;= v \cos \theta  \\
\dot{y} &amp;= v \sin \theta \\
\dot{\theta} &amp;= \omega.
\end{align}
\]</span>
<ul>
<li>The x axis points in the forward direction of the robot and the angle <span class="math inline">\(\theta\)</span> is relative to the world x-axis.</li>
<li>Assume that the robot starts at configuration <span class="math inline">\((x,y,\theta) = (0, 0, 0)\)</span> in the world coordinate frame.</li>
</ul>
<p>Your goal is to make the turtlebot follow a figure-eight trajectory:</p>
<span class="math display">\[\begin{align}
x_d(t) &amp;= \frac{W}{2} \sin \frac{2 \pi t}{T} \\
y_d(t) &amp;= \frac{H}{2} \sin \frac{4 \pi t}{T} 
\end{align}
\]</span>
<p>where <span class="math inline">\(t\)</span> is time, <span class="math inline">\(T\)</span> is the time to finish one figure-eight, <span class="math inline">\(W\)</span> is the width of the figure-eight , and <span class="math inline">\(H\)</span> is the height of the figure-eight.</p>
<h2 id="what-to-implement">What to implement</h2>
<ol>
<li>A node called <code>trajectory</code>
<ul>
<li>Publishes:
<ul>
<li><code>cmd_vel (geometry_msgs/Twist)</code>. This is published at a fixed frequency, causing the turtlebot to follow the desired open-loop trajectory
<ul>
<li>It is up to you to find an appropriate frequency, but 10 Hz is too slow and 1 kHz is faster than needed.</li>
</ul></li>
<li><code>path (nav_msgs/Path)</code>. A <a href="http://wiki.ros.org/rviz/DisplayTypes/Path">Path</a> draws a continuous line in <code>rviz</code>. This path should be the <code>open-loop</code> (i.e., expected) trajectory of the robot.</li>
</ul></li>
<li>Broadcasts:
<ul>
<li>A static transform from <code>world</code> to <code>odom</code>. The <code>world</code> frame and <code>odom</code> frame are co-located. However, when the <code>turtlebot</code> is at (0, 0, 0) in the odom frame it should be at <span class="math inline">\(0, 0, \theta_0\)</span> in the world frame, where <code>\theta_0</code> is the initial angle of the robot on its figure-eight trajectory</li>
</ul></li>
<li>Subscribes:
<ul>
<li><code>reset</code>: This should be the same topic that the turtlebot3 itself listens to. Restarts the trajectory from (0,0,0)</li>
</ul></li>
<li>Services:
<ul>
<li><code>pause (type up to you)</code> Stop the turtle's motion, in a way that the trajectory can be resumed</li>
<li><code>resume (type up to you)</code> Resume the turtle's motion along the trajectory</li>
</ul></li>
<li>Parameters:
<ul>
<li><code>width</code>: The width of the figure eight</li>
<li><code>height</code>: The height of the figure eight</li>
<li><code>period</code>: The amount of time it takes to complete the figure eight</li>
<li><code>~pub_freq</code>: The frequency at which to publish the messages. This is a private parameter.</li>
<li>Pick parameters that fit your location and the turtlebot's capabilities.</li>
</ul></li>
</ul></li>
<li>A pure python package called <code>homework2</code> and located under <code>src/homework2</code>
<ul>
<li>This package should contain code that performs calculations related to the trajectory and control but does not interact with the hardware</li>
<li>Generally, code that performs calculations is much easier to test and can be used in a wide variety of situations so it makes sense to split it from the node code.</li>
<li>This code should not use any <code>rospy</code> functions at all</li>
<li>A useful structure is to have two classes, although you need not follow this structure:
<ol>
<li><code>FigureEight</code> is responsible for all calculations related to <code>FigureEight</code> trajectories:
<ul>
<li>It should be able to provide the trajectory coordinates and derivatives at any given time for a set of parameters.</li>
</ul></li>
<li><code>Kinematics</code> is responsible for the calculations related to the kinematics of the turltebot
<ul>
<li>This class can use <code>FigureEight</code> to compute the appropriate control inputs to follow the trajectory</li>
<li>In general, multiple trajectory shapes could be supported by substituting <code>FigureEight</code> with another class for a different trajectory
<ul>
<li>You need not support multiple trajectory shapes, but this may be a helpful way of thinking about how to organize the code.</li>
</ul></li>
</ul></li>
</ol></li>
<li>At a minimum, the package should provide functions to
<ul>
<li>Compute the trajectory and its derivatives at a given time</li>
<li>Compute the proper control inputs at a given time</li>
</ul></li>
<li>The <code>trajectory</code> node will import the <code>homework2</code> package to do its calculations and use the results to control the robot</li>
</ul></li>
<li>Unit tests for your python package using <code>rossunit</code> and <code>unittests</code>
<ul>
<li>You should be able to run the tests from <code>catkin_make test</code></li>
<li>Test each of the following computations at <span class="math inline">\(t = 0\)</span> and at least one other time <span class="math inline">\(t\)</span>: <span class="math inline">\(x_d(t)\)</span>, <span class="math inline">\(y_d(t)\)</span>, <span class="math inline">\(\dot{x}_d(t)\)</span>, <span class="math inline">\(\dot{y}_d(t)\)</span>, <span class="math inline">\(\ddot{x}_d(t)\)</span>, <span class="math inline">\(\ddot{y}_d(t)\)</span>, <span class="math inline">\(v(t)\)</span>, <span class="math inline">\(\omega(t)\)</span>.</li>
<li>The functions that you test should be the ones actually used by your code to implement the trajectory tracking control law.</li>
</ul></li>
<li>A <code>config</code> directory containing
<ul>
<li>A <code>trajectory.yaml</code> file containing the trajectory parameters</li>
<li>A <code>turtle_view.rviz</code> file containing your <code>rviz</code> setup.</li>
</ul></li>
<li>A launchfile in the <code>launch/</code> directory called <code>figure_eight.launch</code> that
<ol>
<li>Loads the <code>width</code>, <code>height</code>, <code>period</code> parameters from <code>trajectory.yaml</code></li>
<li>Starts the <code>trajectory</code> node, including setting the <code>pub_freq</code> parameter (this parameter can be hard-coded in the launchfile)</li>
<li>Provides an option to launch <code>rqt_plot</code> and show the turtlebot's <code>x</code> and <code>y</code> position (from odometry) vs time</li>
<li>Provides an option to launch the turtlebot Gazebo simulation or start code on the real robot</li>
<li>Provides an option to visualize the robot model in RViz, using the <code>/odom</code> frame as the fixed frame
<ul>
<li>When launching <code>rviz</code> you should load <code>turtle_view.rviz</code> to get the <code>rviz</code> settings</li>
<li>Use the <code>-d</code> argument to <code>rviz</code> to load a <code>.rviz</code> configuration file that you create to set up the fixed frame properly and make.</li>
<li>Remember to use <code>$(find)$</code> when referencing files stored in packages.</li>
<li>Your <code>rviz</code> should display:
<ol>
<li>The fixed frame should be <code>/odom</code></li>
<li>The path that you publish from the trajectory node</li>
<li>All <code>tf</code> frames</li>
<li>The robot model</li>
</ol></li>
</ul></li>
</ol></li>
<li>Documentation showing how you computed the control inputs from the trajectory. You should link/refer to the documentation in your README.md. A few valid methods of showing the computations are:
<ol>
<li>Python code using <code>sympy</code> to perform the calculations</li>
<li>A Mathematica Notebook</li>
<li>A picture or scan of handwritten calculations</li>
<li>A pdf of calculations written in <code>latex</code></li>
<li>Directly embedded in your README using something like <code>readme2tex</code></li>
</ol></li>
<li>Videos:
<ul>
<li>A screencast of the robot in <code>rviz</code></li>
<li>A video of the robot completing a figure eight in real life. Do not worry about how accurate this is.
<ul>
<li>If you don't have a robot, include a screencast of the turtlebot moving in simulation</li>
</ul></li>
<li>Videos can be a link to a sharing site in your README or as a <code>gif</code> file.</li>
</ul></li>
</ol>
<h2 id="hints">Hints</h2>
<ol>
<li>Even if you have a robot, it makes sense to test this in simulation prior to using it for the robot.
<ul>
<li>You can also test in <code>turtlesim</code> if you would like</li>
</ul></li>
<li>Use a timer running at a specified frequency to publish the velocity commands to the turtle.
<ul>
<li>Since the trajectory is continuous but you are sending discrete commands, you need the timer to publish fast enough relative to the turtle's speed to follow the trajectory effectively.</li>
</ul></li>
<li>ROS offers some standard services in the <a href="https://wiki.ros.org/std_srvs">std_srvs</a> package, which can be useful for your pause/resume services.</li>
<li>The <a href="https://emanual.robotis.com/docs/en/platform/turtlebot3/bringup/#ros-1-bringup">Turtlebot3 bringup</a> guide provides a guide for how to start running the actual robot
<ul>
<li>You will need to manually run a launchfile on the <code>turtlebot3</code>, but you should include <code>turtlebot3_bringup/turtlebot3_robot.launch</code> in your own launchfile so it does not need to be called separately.</li>
<li>It is possible to make everything work from a single launchfile, but you will have to write it yourself and it is not necessary for this assignment.</li>
</ul></li>
<li><a href="https://emanual.robotis.com/docs/en/platform/turtlebot3/simulation/#ros-1-simulation">Simulation</a> provides a guide for how to get started with the gazebo simulator
<ul>
<li>We will use Gazebo, not Fake Node</li>
<li>For our purposes, you can just <code>roslaunch turtlebot3_gazebo turtlebot3_empty_world.launch</code>. You can include this launchfile in your own launchfile to launch gazebo</li>
</ul></li>
<li>You can also look at the contents of the <code>turtlebot3</code> launchfiles to get a feel for what's going on.</li>
<li>The <code>turtlebot3</code> gazebo simulation is pretty much a drop-in replacement for running the actual turtlebot3 nodes.</li>
<li>To accomplish this task, you will take advantage of the <a href="http://planning.cs.uiuc.edu/node850.html">differential flattness</a> of the system.
<ul>
<li>The overall goal is to solve for the control inputs <span class="math inline">\(v\)</span> and <span class="math inline">\(\omega\)</span> that will result in the desired trajectory</li>
<li>Because the system is differentially flat, we can find these expressions without integrating the differential equations describing the kinematics of the robot</li>
</ul></li>
</ol>
<h3 id="practical-differential-flatness-guide">Practical Differential Flatness Guide</h3>
<ol>
<li>Solve the kinematic equations for <span class="math inline">\(\theta = f(\dot{x}, \dot{y})\)</span>, (thus <span class="math inline">\(\theta\)</span> is some function <span class="math inline">\(f\)</span> that depends only on <span class="math inline">\(\dot{x}\)</span> and <span class="math inline">\(\dot{y}\)</span>.
<ul>
<li>Find <span class="math inline">\(\dot{\theta} = f&#39;(\dot{x}, \dot{y})\)</span>.</li>
<li>Notice that this derivative depends only on <span class="math inline">\(\dot{x}\)</span>, <span class="math inline">\(\ddot{x}\)</span>, <span class="math inline">\(\dot{y}\)</span>, and <span class="math inline">\(\ddot{y}\)</span>.</li>
<li>Notice that <span class="math inline">\(\omega = \dot{\theta}\)</span>, thus given a reference trajectory and its derivatives you can directly find the steering angle to stay on a given trajectory.</li>
</ul></li>
<li>Use your equation for <span class="math inline">\(\theta\)</span> to solve for <span class="math inline">\(v = g(\dot{x}, \dot{y}, \ddot{x}, \ddot{y})\)</span>
<ul>
<li>What is <span class="math inline">\(\dot{x}^2 + \dot{y}^2\)</span>?</li>
</ul></li>
<li>You have now solved for the controls <span class="math inline">\(w\)</span> and <span class="math inline">\(v\)</span> directly in terms of the vehicle's (<span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>) position and derivatives.</li>
<li>The robot follows a trajectory when <span class="math inline">\(x(t) = x_d(t)\)</span> and <span class="math inline">\(y(t) = y_d(t)\)</span>. You can achieve this behavior by
<ol>
<li>Taking the necessary derivatives of <span class="math inline">\(x_d(t)\)</span> and $y_d(t)</li>
<li>Substituting these derivatives into your expressions for <span class="math inline">\(v\)</span> and <span class="math inline">\(\omega\)</span></li>
<li>At least in theory, the robot will follow the trajectory. In practice there will be small errors from wheel slipping, dynamics, and control timing.</li>
</ol></li>
</ol>
<h1 id="part-ii-xacro-arm">Part II: Xacro ARM</h1>
<p>In this section you will be creating a <a href="http://wiki.ros.org/xacro">Xacro</a> <a href="https://wiki.ros.org/urdf">URDF</a> for the robot arm shown below and visualizing it in rviz, and then making it's end-effector follow a trajectory.</p>
<figure>
<img src="./twolink.png" alt="A 2 - link robot arm. The length of the upper and lower links are L_1 and L_2." /><figcaption aria-hidden="true">A 2 - link robot arm. The length of the upper and lower links are <span class="math inline">\(L_1\)</span> and <span class="math inline">\(L_2\)</span>.</figcaption>
</figure>
<h2 id="what-to-turn-in">What to turn in</h2>
<p>This is just a list of what to turn in, it is not necessarily ordered by what you should do first. Pay close attention to the desired orientation of the arm and its reference frames.</p>
<ol>
<li><p>Create a xacro urdf file for the robot arm.</p>
<ul>
<li>It should read and use lengths <span class="math inline">\(L_1\)</span> and <span class="math inline">\(L_2\)</span> from a file <code>config/arm.yaml</code>. Be sure to choose lengths such that <span class="math inline">\(L_1 \neq L_2\)</span>.
<ul>
<li>See <a href="http://wiki.ros.org/xacro#YAML_support">Xacro Yaml Support</a></li>
</ul></li>
<li>When <span class="math inline">\(\theta_1 = 0\)</span> and <span class="math inline">\(\theta_2 = 0\)</span>, the robot should be completely horizontal, with the coordinates of the end-effector (i.e., the tip of link 2) relative to the fixed frame being <span class="math inline">\((L_1 + L_2, 0, 0)\)</span>.</li>
<li>Each link should be a different color when displayed in <code>rviz</code>.</li>
<li>Each link should be visualized as a cylinder, whose height is the length of that link.</li>
<li>The model is purely kinematic, so no need to worry about inertias or collisions.</li>
<li>No need to worry about joint limits.</li>
<li>There should be a frame at the location of the robot's end-effector.</li>
<li>The arm should be in the <span class="math inline">\(xy\)</span> plane of your <code>&lt;Fixed Frame&gt;</code>.
<ul>
<li>In other words the robot is rotating in the plane of the "ground" since the z axis points up in rviz.</li>
<li>In <code>rviz</code> the x axis is red, y axis is green, and z axis is blue</li>
</ul></li>
<li>Each joint frame should have the <span class="math inline">\(z\)</span> axis pointing up (i.e., the <span class="math inline">\(z\)</span> axis is the axis of rotation) and the <span class="math inline">\(x\)</span> axis pointing along the length of the arm.</li>
</ul></li>
<li><p>A launchfile that starts</p>
<ul>
<li>A <code>robot_state_publisher</code></li>
<li>The <code>joint_state_publisher</code> (optionally)</li>
<li>The <code>joint_state_publisher_gui</code> (optionally)</li>
<li>Rviz <code>rviz</code> (optionally).</li>
<li>If rviz is loaded, you should use the <code>-d</code> option to load a <code>.rviz</code> configuration file that you create to set up the fixed frame properly and make.</li>
<li>Remember to use <code>$(find)$</code> when referencing files stored in packages.</li>
<li>Document how to use your launchfile</li>
</ul></li>
<li><p>A node called <code>arm_traj</code> that causes the end-effector to track the following trajectory:</p>
<span class="math display">\[\begin{align}
     x(t) &amp;= 0.9\cos\frac{2\pi t}{T} \sqrt{(L_1+L_2)^2 - h^2}  \\
     y(t) &amp;= \frac{2}{3}(L_1 + L_2)
\end{align}
\]</span>
<ul>
<li>Let <span class="math inline">\(h=\frac{2}{3}(L_1 + L_2)\)</span> so that the trajectory is always achievable.</li>
<li>The trajectory should result in the end-effector moving back and forth in a straight line with a constant <span class="math inline">\(y\)</span> value</li>
<li>The node should read the parameters <span class="math inline">\(L_1\)</span>, <span class="math inline">\(L_2\)</span>, and <span class="math inline">\(T\)</span> from the parameter server (but not <span class="math inline">\(h\)</span>).</li>
<li>Unlike with the turtle trajectory, here you can specify joint angles directly by publishing <code>sensor_msg/JointState</code> messages on <code>joint_state</code>.
<ul>
<li>Therefore, you only need the inverse kinematics: no derivatives.</li>
</ul></li>
<li>You can derive the inverse kinematics, look them up (e.g., in Lynch, Park, <em>Modern Robotics</em> Chapter 6, cite your source), or use <code>tf2</code> to compute them for you.</li>
<li>The locations on the trajectory should be published at a fixed frequency that results in the motion of the arm appearing smooth</li>
<li>Each joint state message has a header of type <code>std_msgs.msgs.Header</code>
<ul>
<li>set the stamp member to the current time before you send the message</li>
<li>seq is set automatically by the publisher</li>
<li>frame_id is used by <code>/tf</code> so it can also be left blank for JointState messages</li>
</ul></li>
</ul></li>
<li><p>A node called <code>arm_marker</code> that draws markers in <code>rviz</code> at the end-effector position.</p>
<ul>
<li>One cycle should take <span class="math inline">\(T\)</span> seconds: you should read <span class="math inline">\(T\)</span> from the parameter server so you use the same value as in your trajectory node</li>
<li>The markers should disappear after <span class="math inline">\(\frac{T}{5}\)</span> seconds</li>
<li>The markers should be published at a fixed rate</li>
<li>You likely will need to publish these markers at a significantly slower rate than the trajectory updates because they can be slow to process.</li>
<li>You can use any shape you want</li>
<li>The color and shape should change if the <code>x</code> coordinate is positive or negative
<ul>
<li>You should get the position of the end-effector using a <code>tf</code> listener</li>
</ul></li>
</ul></li>
<li><p>A launchfile that lets you run all the nodes you've created and visualize the results. It should:</p>
<ul>
<li>Use an <code>&lt;include&gt;</code> tag to load launchfile from step 2, launching rviz and the <code>robot_state_publisher</code> and either the <code>joint_state_publisher</code> or your trajectory generation node.</li>
<li>An option to run the node that sends the markers to rviz.</li>
<li>The launchfile should load <span class="math inline">\(L_1\)</span>, <span class="math inline">\(L_2\)</span> and <span class="math inline">\(T\)</span> into the parameter server from a yaml file called <code>arm.yaml</code></li>
<li>Hint: you may wish to write this launchfile incrementally, adding new <code>&lt;node&gt;</code> tasks for each node you create.</li>
</ul></li>
<li><p>A discussion in your <code>README.md</code> about what each launchfile and node is called and what it does. Comments in the docstring of each node should describe the ROS api for each node (publishers, subscribers, services, etc.).</p></li>
<li><p>Make a video of a robot following the trajectory and link to it or embed it in your <code>README</code></p></li>
</ol>
<h1 id="part-iii-pincherx-100">Part III: PincherX 100</h1>
<ul>
<li>You will now adapt the <code>arm_traj</code> node to work with the <code>pincherX 100</code> robot
<ul>
<li>You can either make <code>arm_traj</code> also publish <code>interbotix_sdk/JointCommands</code> in addition to the <code>joint_state</code> commands or write an adapter node that reads the <code>joint_states</code> published by <code>arm_traj</code> and publishes <code>interbotix_sdk/JointCommands</code></li>
<li>You should be publishing joint positions</li>
<li>Essentially, the joint positions of the <code>pincherX</code> are copying those of your <code>urdf</code>, as driven by <code>arm_traj</code></li>
</ul></li>
<li>Create the <code>pincherX</code> as a planar robot arm. That is, keep all joints except fixed except for the shoulder and elbow
<ul>
<li>The dimensions of the arm can be found <a href="http://www.support.interbotix.com/html/specifications/px100.html">here</a></li>
<li>Store the dimensions for <span class="math inline">\(L_1\)</span> and <span class="math inline">\(L_2\)</span> in <code>config/px100.yaml</code></li>
</ul></li>
<li>Create a launchfile that launches the necessary <code>px100</code> launchfiles and loads <code>rviz</code>.
<ul>
<li><code>rviz</code> should display both the <code>px100</code> and your <code>urdf</code></li>
<li>You should publish a static transform between their base_links</li>
</ul></li>
<li>Try your code using the <code>pincherX 100</code> simulator first and make sure it works prior to trying with the real arm</li>
<li>Turn in a screencast of the pincherX 100 and your robot moving within <code>rviz</code></li>
<li>Turn in a video of the actual robot moving</li>
</ul>
<h2 id="hints-1">Hints</h2>
<ul>
<li><a href="https://github.com/Interbotix/interbotix_ros_arms">Official Documentation</a></li>
<li>Our robot model is referred to as <code>px100</code></li>
</ul>
</div>
<div class="footer">
Author: Matthew Elwin.
</div>
</div>
</div>

</body>
</html>
